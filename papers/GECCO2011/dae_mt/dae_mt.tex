% This is "sig-alternate.tex" V1.9 April 2009
% This file should be compiled with V2.4 of "sig-alternate.cls" April 2009
%
% This example file demonstrates the use of the 'sig-alternate.cls'
% V2.4 LaTeX2e document class file. It is for those submitting
% articles to ACM Conference Proceedings WHO DO NOT WISH TO
% STRICTLY ADHERE TO THE SIGS (PUBS-BOARD-ENDORSED) STYLE.
% The 'sig-alternate.cls' file will produce a similar-looking,
% albeit, 'tighter' paper resulting in, invariably, fewer pages.
%
% ----------------------------------------------------------------------------------------------------------------
% This .tex file (and associated .cls V2.4) produces:
%       1) The Permission Statement
%       2) The Conference (location) Info information
%       3) The Copyright Line with ACM data
%       4) NO page numbers
%
% as against the acm_proc_article-sp.cls file which
% DOES NOT produce 1) thru' 3) above.
%
% Using 'sig-alternate.cls' you have control, however, from within
% the source .tex file, over both the CopyrightYear
% (defaulted to 200X) and the ACM Copyright Data
% (defaulted to X-XXXXX-XX-X/XX/XX).
% e.g.
% \CopyrightYear{2007} will cause 2007 to appear in the copyright line.
% \crdata{0-12345-67-8/90/12} will cause 0-12345-67-8/90/12 to appear in the copyright line.
%
% ---------------------------------------------------------------------------------------------------------------
% This .tex source is an example which *does* use
% the .bib file (from which the .bbl file % is produced).
% REMEMBER HOWEVER: After having produced the .bbl file,
% and prior to final submission, you *NEED* to 'insert'
% your .bbl file into your source .tex file so as to provide
% ONE 'self-contained' source file.
%
% ================= IF YOU HAVE QUESTIONS =======================
% Questions regarding the SIGS styles, SIGS policies and
% procedures, Conferences etc. should be sent to
% Adrienne Griscti (griscti@acm.org)
%
% Technical questions _only_ to
% Gerald Murray (murray@hq.acm.org)
% ===============================================================
%
% For tracking purposes - this is V1.9 - April 2009

\documentclass{sig-alternate}
\usepackage{url}
%\documentclass{acm_proc_article-sp}
%\def\BibTeX{Bib\TeX}
%\parindent=0pt
%\parskip=\baselineskip

\newcommand{\dae}{{\em Divide-and-Evolve}}
\newcommand{\DAEX}{{\sc DaE$_{\text{X}}$}}
\newcommand{\DAEYAHSP}{{\sc DaE$_{\text{YAHSP}}$}}
\newcommand{\YAHSP}{{\sc YAHSP}}

\def\UU{{\mathbb{U}}}


\begin{document}

%\title{A Multicore Implementation of the Divide-and-Evolve Algorithm}
%\title{Speeding Up the Individual Evaluation of the Divide-and-Evolve Algorithm}
%\title{Multithreading the Divide-and-Evolve Algorithm for a Multicore Machine}
%\title{A Multithreaded Release of the Divide-and-Evolve Planning System for a Multicore Machine}
%\title{A Multicore Implementation of the Individual Evaluation in the Divide-and-Evolve Planner}
\title{Parallel Divide-and-Evolve: Experiments with OpenMP on a Multicore Machine}


%
% You need the command \numberofauthors to handle the 'placement
% and alignment' of the authors beneath the title.
%
% For aesthetic reasons, we recommend 'three authors at a time'
% i.e. three 'name/affiliation blocks' be placed beneath the title.
%
% NOTE: You are NOT restricted in how many 'rows' of
% "name/affiliations" may appear. We just ask that you restrict
% the number of 'columns' to three.
%
% Because of the available 'opening page real-estate'
% we ask you to refrain from putting more than six authors
% (two rows with three columns) beneath the article title.
% More than six makes the first-page appear very cluttered indeed.
%
% Use the \alignauthor commands to handle the names
% and affiliations for an 'aesthetic maximum' of six authors.
% Add names, affiliations, addresses for
% the seventh etc. author(s) as the argument for the
% \additionalauthors command.
% These 'additional authors' will be output/set for you
% without further effort on your part as the last section in
% the body of your article BEFORE References or any Appendices.
\numberofauthors{2} % 4 is a bug!

\author{
\alignauthor
Caner Candan\\
       \affaddr{Thales Research \& Technology}\\
       \affaddr{Palaiseau, France}\\
       \email{caner.candan@thalesgroup.com}
\alignauthor
Johann Dr{\'e}o\\
       \affaddr{Thales Research \& Technology}\\
       \affaddr{Palaiseau, France}\\
       \email{johann.dreo@thalesgroup.com}
\and
\alignauthor
Pierre Sav{\'e}ant\\
       \affaddr{Thales Research \& Technology}\\
       \affaddr{Palaiseau, France}\\
       \email{pierre.saveant@thalesgroup.com}
\alignauthor
Vincent Vidal\\
       \affaddr{ONERA -- DCSD}\\
       \affaddr{Toulouse, France}\\
       \email{vincent.vidal@onera.fr}
}


%\numberofauthors{2}
%\author{
%\alignauthor
%Caner Candan\\
%Johann Dr{\'e}o\\
%Pierre Sav{\'e}ant\\
%\affaddr{Thales Research \& Technology}\\
%\affaddr{Palaiseau, France}\\
%\email{first.last@thalesgroup.com}
%\alignauthor
%Vincent Vidal\\
%\affaddr{ONERA -- DCSD}\\
%\affaddr{Toulouse, France}\\
%\email{Vincent.Vidal@onera.fr}
%}

%\numberofauthors{2}
%\author{
%\alignauthor
%Caner Candan$^{1}$ ~~~~~~~~ Johann Dr{\'e}o$^{1}$\\
%\affaddr{$^{1}$Thales Research \& Technology}\\
%\affaddr{Palaiseau, France}\\
%\email{first.last@thalesgroup.com}
%\alignauthor
%Pierre Sav{\'e}ant$^{1}$ ~~~~~~~~ Vincent Vidal$^{2}$\\
%\affaddr{$^{2}$ONERA -- DCSD}\\
%\affaddr{Toulouse, France}\\
%\email{Vincent.Vidal@onera.fr}
%}

%\numberofauthors{4}
%\author{
%\alignauthor
%Caner Candan\\
%\affaddr{Thales Research \& Technology}\\
%\affaddr{Palaiseau, France}\\
%\email{first.last@thalesgroup.com}
%\alignauthor
%Johann Dr{\'e}o\\
%\alignauthor
%Pierre Sav{\'e}ant\\
%\alignauthor
%Vincent Vidal\\
%\affaddr{ONERA -- DCSD}\\
%\affaddr{Toulouse, France}\\
%\email{Vincent.Vidal@onera.fr}
%}

\maketitle
\begin{abstract}
This paper provides 

contribution: work on EO level of abstraction ... (reusable by other)

proof of concept with DAE.

\end{abstract}

\section{Introduction}

$\UU$ denotes a uniform random draw from the set given as argument.


Preliminary work

\section{Divide-and-Evolve}

The planning problem is to find a path in a transition system from an initial state to a state including a set of desired goals. In domain-independent planning, problems are described with the Planning Domain Description Language (PDDL); states of the world are defined by a set of atoms instanciated from a set of predicates and a set of objects. Although there are several families of problems, we concentrate here on cost planning and temporal planning. In cost planning a cost is attached to each action and the objective is to minimize the sum of all costs for a sequential plan whereas in temporal planning actions have a duration and can be run in parallel. In temporal planning the objective is to minimize the total makespan of the parallel plan.

\DAEX\ is a domain-independent satisficing planning system \cite{dae:evocop2006} based on Evolutionary Computation. The basic principle is to carry out a {\em Divide-and-Conquer} strategy driven by an evolutionary algorithm. The algorithm is detailed in \cite{dae:icaps2010} and compare with state-of-the-art planners.

A \DAEX\ individual is a sequence of goals which define a sequence of subproblems to be solved. These subproblems are submitted to an embedded planner and the global solution is obtained after a compression step. The overall optimization process is controled by an evolutionary algorithm.
The fitness implements a gradient towards feasability for unfeasible individuals and a gradient towards optimality for feasible individuals.
Beside a standard one point crossover, four mutations have been defined at the individual level and at the goal level.
The selection is a comparison-based deterministic tournament of size 5.
% Parameter tuning
For the sequential release, Darwinian-related parameters of \DAEX\ have been fixed after some early experiments \cite{dae:evocop2006} wheras 
parameters related to the variation operators have been tuned using Racing \cite{dae:gecco2010}.

All experiments were done with \DAEYAHSP: the instantiation of \DAEX\ with the YAHSP heuristic forward search solver \cite{yahsp:icaps2004}. % + YAHSP memoing shared by all searches.
We added two novelties to the version described in \cite{dae:icaps2010}. 
One important parameter is the maximum number of expanded nodes allowed to the \YAHSP\ sub-solver which defines empirically what is considered as an easy problem for \YAHSP. As the matter of fact, the minimum number of required nodes varies from few nodes to thousands depending of the problem. 
In the current release this number is estimated during the population initialization stage. An incremental loop is performed until the ratio of feasible individals is over a given theshold or a maximum boundary has been reached. By default this number is doubled at each iteration until at least one feasible individual is produced or 100000 has been reached.

Furthermore we add the capability to perform restarts within a time contract in order to increase solution quality.

\section{IPC Benchmarks}

We have tested the above implementation on two benchmarks from the satisficing track of the $6^{th}$ International Planning Competition\footnote{\url{http://ipc.icaps-conference.org}}: Elevators-12 for cost planning and Openstacks-17 for temporal planning.

The elevators domain\footnote{\url{http://ipc.informatik.uni-freiburg.de/Domains}} is stated as follows: there is a building with N+1 floors, numbered from 0 to N. The building can be separated in blocks of size M+1, where M divides N. Adjacent blocks have a common floor. The building has K fast (accelarating) elevators that stop only in floors that are multiple of M/2 (so M has to be an even number). Each fast elevator has a capacity of X persons. Furthermore, within each block, there are L slow elevators, that stop at every floor of the block. Each slow elevator has a capacity of Y persons (usually Y<X).
There are costs associated with each elavator starting/stoping and moving. There are several passengers, for which their current location and their destination are given.
The objective function is to minimize the total cost of moving the passengers to their destinations. The total cost is increased each time an elevator starts/stops or moves.

The openstacks domain\footnote{\url{http://ipc.informatik.uni-freiburg.de/Domains}} is based on the "minimum maximum simultaneous open stacks" combinatorial optimization problem, which can be stated as follows: a manufacturer has a number of orders, each for a combination of different products, and can only make one product at a time. The problem is to order the making of the different products so that the maximum number of stacks that are in use simultaneously, or equivalently the number of orders that are in simultaneous production, is minimized. The problem is NP-hard and known to be equivalent to several other problems. In the temporal case a maximum number of stacks is given and the goal is to find the plan with the least makespan, without violating the maximum number of stacks constraints.


\section{Hardware}
The algorithm is programmed in C++ using the GNU OpenMP threading library (GOMP) and run on a 48-core DELL PowerEdge R815 Rack Server set up with four 12-core AMD Opteron(tm) 6174, 2.2GHz (12x512 KB cache) processors with 192GB of RAM.

Multicore machines are becoming a standard way to speep up the system performance.

This paper describes a multi-threaded release of \DAEYAHSP.

This paper describes a parallel shared-memory release of the \DAEYAHSP\ planning system.
using the OpenMP directive-based API.

to obtain high levels of performance special care has been given to get reentrant procedures.
isolate context variables 

% concurrent programming

OpenMP primarily consists of a set of compiler directives (pragmas) that are inserted into a Fortran, C or C++ program to convey information to an OpenMP compiler.


\cite{paradiseo:JHeuristics2004}
\cite{paradiseo:ParallelComputing2004}
\cite{alba:IEEE2002}
\cite{alba:COR2008}
\cite{alba:IPL2002}
\cite{burns:JAIR2010}
\cite{burns:icaps2009}
\cite{burns:ijcai2009}
\cite{vidal:socs2010}
\cite{dae:icaps2010}
\cite{dae:evocop2006}
\cite{dae:gecco2010}
\cite{yahsp:icaps2004}

\section{Discussion and Conclusion}

%ACKNOWLEDGMENTS are optional
%\section{Acknowledgments}

%
% The following two commands are all you need in the
% initial runs of your .tex file to
% produce the bibliography for the citations in your paper.
\bibliographystyle{abbrv}
\bibliography{dae_mt}  % sigproc.bib is the name of the Bibliography in this case
% You must have a proper ".bib" file
%  and remember to run:
% latex bibtex latex latex
% to resolve all references
%
% ACM needs 'a single self-contained file'!
%
%Generated by bibtex from your ~.bib file.  Run latex,
%then bibtex, then latex twice (to resolve references)
%to create the ~.bbl file.  Insert that ~.bbl file into
%the .tex source file and comment out
%the command \texttt{{\char'134}thebibliography}.
\end{document}


IPC-6 ELEVATORS DOMAIN

The idea for this domain came up from the Miconic domain of IPC2, however the domain has been designed from scratch. The scenario is the following: There is a building with N+1 floors, numbered from 0 to N. The building can be separated in blocks of size M+1, where M divides N. Adjacent blocks have a common floor. For example, suppose N=12 and M=4, then we have 13 floors in total (ranging from 0 to 12), which form 3 blocks of 5 floors each, being 0 to 4, 4 to 8 and 8 to 12.

The building has K fast (accelarating) elevators that stop only in floors that are multiple of M/2 (so M has to be an even number). Each fast elevator has a capacity of X persons. Furthermore, within each block, there are L slow elevators, that stop at every floor of the block. Each slow elevator has a capacity of Y persons (usually Y<X).

There are costs associated with each elavator starting/stoping and moving. In particular, fast (accelarating) elevators have negligible cost of starting/stoping but have significant cost while moving. On the other hand, slow (constant speed) elevators have significant cost when starting/stoping and negligible cost while moving. Travelling times between floors are given for any type of elevator, taking into account the constant speed of the slow elevators and the constant acceleration of the fast elevators.

There are several passengers, for which their current location (i.e. the floor they are) and their destination are given. The planning problem is to find a plan that moves the passengers to their destinations while it maximizes some criterion.

The versions of this domain are the following:

    * Sequential: The objective function is to minimize the total cost of moving the passengers to their destinations . The total cost is increased each time an elevator starts/stops or moves.
    * Time: Each action has a duration. The goal is to minimize the makespan of the plan.
          o Time-numeric: Similar to the 'time' version; numeric fluents have been used to represent floors and capacities. 
    * Net-benefit: Having the passengers to their destinations is a soft-goal. There is a penalty associated with any passenger not being in their destination floor. The penalty is a function of the difference between the origin and the destination floor (it is supposed that the passenger with use the stairs). The objective function is to minimize the total cost expressed as a function of the cost of moving the elevators and the cost of not serving the passengers.
          o Net-benefit - numeric: Similar to net-benefit; numeric fluents have been used to represent floors and capacity constraints. 


IPC-6 OPENSTACKS DOMAIN

This domain has been used first at IPC-2006. At IPC-2008 we kept the same scenario, however we produced entirely new problem sets. So, the scenario is the following (adapted from the IPC-2006 description):

The openstacks domain is based on the "minimum maximum simultaneous open stacks" combinatorial optimization problem, which can be stated as follows: A manufacturer has a number of orders, each for a combination of different products, and can only make one product at a time.

The total required quantity of each product is made at the same time (because changing from making one product to making another requires a production stop). From the time that the first product included in an order is made to the time that all products included in the order have been made, the order is said to be "open" and during this time it requires a "stack" (a temporary storage space). The problem is to order the making of the different products so that the maximum number of stacks that are in use simultaneously, or equivalently the number of orders that are in simultaneous production, is minimized (because each stack takes up space in the production area).

The problem is NP-hard and known to be equivalent to several other problems. It was recently posed as a challenge problem for the constraint programming community (see http://www.dcs.st-and.ac.uk/~ipg/challenge/).

Note that this is an optimization problem: for any instance of the problem every ordering of the making of products is a solution, which at worst uses as many simultaneously open stacks as there are orders. Thus, finding a plan is quite trivial (in the sense that there exists a domain-specific linear-time algorithm that solves the problem), but finding a plan of high quality is hard (even for a domain-specific algorithm).

The following versions of the Openstacks domain have been used at IPC-2008:

    * Sequential: The goal is to minimize the total number of stacks. The number of stacks is represented using symbols. There are two versions of the domain in this track:
          o ADL: Universally quantified preconditions are used in order to ensure that all related orders have been started before making a product, or that all related products have been produced before shipping an order.
          o Semiground: Universally quantified preconditions have been replaced by multiple semiground actions. 
    * Time: In this case a maximum number of stacks is given and the goal is to find the plan with the least makespan, wothout violating the maximum number of stacks constraint. There are four versions of the domain in this track:
          o ADL: Similar to ADL of sequential track.
          o Semiground: Similar to semiground of sequential track.
          o ADL-numeric: Similar to ADL, but numeric fluents are used to represent the number of stacks.
          o Semiground-numeric: Similar to semiground, but numeric fluents are used to represent the number of stacks. 
    * Net-benefit: There is a cost associated with each additional stack used to make the products. Howeverm we can ship an order without all of its products beeing delivered with it. A product is considered "delivered" wrt a specific order, if the order includes the product, the product has been made and at the time the product has been made the order was open. A penalty is associated for each non-delivered product of order. There are two versions of the openstacks domain for this track:
          o ADL: Similar to ADL of the time track.
          o ADL-numeric: Similar to the ADL-numeric of the time track. 

\DAE\ has been implemented within the Evolving Objects framework (\url{http://eodev.sourceforge.net/}), an Open Source, STL-based, C++ Evolutionary Computation library. 
The fixed {\em evolution engine} is a (100+700)-ES: 100 individuals generate 700 offsprings without selection. The survival selection is performed among those 800 individuals using a {\em deterministic tournament} of size 5. For all runs, the {\bf stopping criterion} is the following: After at least 10 generations, evolution is stopped if no improvement of the best fitness in the population is made during 50 generations, with a maximum of 1000 generations. Furthermore, all runs were allowed a maximum CPU time of 30mn (running on 3.4 GHz cores).\\
